--문자열 붙임, 자르기, 길이
--CONCAT(), SUBSTR(), LENGTH()

SELECT CONCAT('FLO','WER'), SUBSTR('FLOWER',1,3), LENGTH('FLOWER')
FROM DUAL;

--BUSAPPLEFLOWER에서 BUS, APPLE, FLOWER 자르기
SELECT SUBSTR('BUSAPPLEFLOWER',1,3),
	SUBSTR('BUSAPPLEFLOWER',4,5),
	SUBSTR('BUSAPPLEFLOWER',9,6)
FROM DUAL;

--JOIN
--EMP 테이블 사원번호로 DEPT 테이블의 지역 검색하기
SELECT E.DEPTNO,E.ENAME,D.LOC
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO=D.DEPTNO;

--PLAYER 테이블에서 송종국 선수가 속한 팀의 전화번호 검색하기
--ON 실행 이후 WHERE 실행(ON->WHERE)
SELECT P.TEAM_ID,P.PLAYER_NAME,T.TEL
FROM PLAYER P JOIN TEAM T
ON P.TEAM_ID=T.TEAM_ID
WHERE PLAYER_NAME='송종국';

--ON에서 한번에 처리하는 것이 ON->WHERE 보다 효율적
SELECT P.TEAM_ID,P.PLAYER_NAME,T.TEL
FROM PLAYER P JOIN TEAM T
ON P.TEAM_ID=T.TEAM_ID AND PLAYER_NAME='송종국';

--JOBS 테이블에서 JOB_ID로 EMPLOYEES의 EMAIL,성 이름 검색
--CONCATENATION 사용
SELECT JOB_TITLE,E.EMAIL,FIRST_NAME||' '||LAST_NAME
FROM JOBS J JOIN EMPLOYEES E
ON J.JOB_ID=E.JOB_ID;

--PLAYER 테이블에서 전체 평균키보다 큰 선수들을 TEAM_ID별로 묶고
--TEAM_ID,TEAM_NAME,그룹별 평균키, 전체 평균키 검색
--TEAM_ID로 오름차순 정렬
--TEAM_ID	TEAM_NAME	그룹평큔기	전체 평균키
SELECT P.TEAM_ID,T.TEAM_NAME,ROUND(AVG(HEIGHT),2) "그룹별 평균키",
	ROUND((SELECT AVG(HEIGHT) FROM PLAYER),2) "전체 평균키"
--FROM절에서 AS 불가
FROM PLAYER P JOIN TEAM T
ON P.TEAM_ID=T.TEAM_ID
WHERE (SELECT AVG(HEIGHT) FROM PLAYER)<HEIGHT
GROUP BY P.TEAM_ID,TEAM_NAME
ORDER BY 1;

--EMPLOYEES 테이블에서 평균급여보다 높은 사원들 JOB_ID별로 묶고
--JOB_ID, DEPARTMENT_ID, 그룹별 평균급여 검색,전체 평균 급여
--그룹 평균 급여 기준 내림차순 정렬
SELECT E.JOB_ID,DEPARTMENT_NAME,AVG(SALARY),
	ROUND((SELECT AVG(SALARY) FROM EMPLOYEES),2)
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE(SELECT AVG(SALARY) FROM EMPLOYEES)<SALARY
GROUP BY E.JOB_ID,DEPARTMENT_NAME
ORDER BY 1;

--비등가 조인
--급여로 등급 나누기
SELECT E.EMPNO,SAL,GRADE,DNAME
FROM EMP E JOIN SALGRADE S
ON E.SAL BETWEEN LOSAL AND HISAL
JOIN DEPT D
ON E.DEPTNO=D.DEPTNO;

SELECT E.EMPNO,D.DNAME,E.SAL,S.GRADE
FROM EMP E,SALGRADE S,DEPT D
WHERE (E.SAL BETWEEN LOSAL AND HISAL)
AND (E.DEPTNO=D.DEPTNO);

--EMPLOYEES 테이블에서 HIREDATE가
--2003년~2005년까지인 사원 검색
--HIRE_DATE,FIRST_NAME,DEPARTMENT_NAME
--HIRE_DATE순으로 정렬
--HTML파일로 열어놓기
SELECT E.HIRE_DATE,E.FIRST_NAME,D.DEPARTMENT_NAME
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID AND
E.HIRE_DATE BETWEEN TO_DATE('2003-01-01','YYYY-MM-DD') AND TO_DATE('2005-12-31','YYYY-MM-DD')
ORDER BY 1;

--NATURAL JOIN
SELECT *
FROM EMP E INNER JOIN DEPT D
USING(DEPTNO);

SELECT *
FROM EMP NATURAL JOIN DEPT;

--외부 조인(OUTER JOIN)
--LEFT OUTER JOIN
SELECT STADIUM_NAME,S.STADIUM_ID,SEAT_COUNT,HOMETEAM_ID,T.TEAM_ID
FROM STADIUM S LEFT OUTER JOIN TEAM T
ON S.HOMETEAM_ID=T.TEAM_ID;

--조건식(ON절) 거짓이어도 출력
SELECT STADIUM_NAME,S.STADIUM_ID,SEAT_COUNT,HOMETEAM_ID,T.TEAM_ID
FROM STADIUM S LEFT OUTER JOIN TEAM T
ON S.HOMETEAM_ID=T.TEAM_ID AND HOMETEAM_ID IS NOT NULL;

SELECT STADIUM_NAME,S.STADIUM_ID,SEAT_COUNT,HOMETEAM_ID,T.TEAM_ID
FROM STADIUM S LEFT OUTER JOIN TEAM T
ON S.HOMETEAM_ID=T.TEAM_ID
WHERE HOMETEAM_ID IS NOT NULL;

--RIGHT OUTER JOIN
SELECT STADIUM_NAME,S.STADIUM_ID,SEAT_COUNT, HOMETEAM_ID,T.TEAM_ID
FROM STADIUM S RIGHT OUTER JOIN TEAM T
ON T.TEAM_ID=S.HOMETEAM_ID;

--FULL OUTER JOIN
SELECT STADIUM_NAME,S.STADIUM_ID,SEAT_COUNT, HOMETEAM_ID
FROM STADIUM S FULL OUTER JOIN TEAM T
ON T.TEAM_ID=S.HOMETEAM_ID;

--크로스 조인(CROSS JOIN)
--거의 쓰지 않음. 이론상 존재
--목적: 모든 경우를 고려한다.
SELECT *
FROM EMPLOYEES E CROSS JOIN DEPARTMENTS D;

--SELF JOIN
SELECT E1.ENAME "사원명",E2.ENAME "매니저명"
FROM EMP E1 JOIN EMP E2
ON E1.MGR=E2.EMPNO;
